name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  RUST_LOG: info

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Create .env file from secrets
        run: |
          cat > .env << EOF
          # Database configuration
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER || 'postgres' }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_DB || 'rusttracker' }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB || 'rusttracker' }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_HOST=localhost
          POSTGRES_PORT=5432

          # Backend configuration
          RUST_LOG=info
          PORT=8080
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRY_HOURS=24

          # Frontend configuration
          FRONTEND_PORT=3000

          # Environment
          APP_ENV=production

          # Rate limiting settings
          MAX_REQUESTS_PER_MINUTE=${{ secrets.MAX_REQUESTS_PER_MINUTE || '100' }}
          RATE_LIMIT_WINDOW_MS=${{ secrets.RATE_LIMIT_WINDOW_MS || '60000' }}
          EOF

      - name: Run quick test suite
        run: make quick-test

      - name: Build application images
        run: |
          echo "Building Docker images..."
          docker compose -f docker/docker-compose.yml build --no-cache

      - name: Verify application startup
        run: |
          echo "Starting application for verification..."
          docker compose -f docker/docker-compose.yml up -d

          # Wait for services to be ready
          sleep 30

          # Check service health
          echo "Checking service health..."
          docker compose -f docker/docker-compose.yml ps

          # Test backend health endpoint
          docker compose -f docker/docker-compose.yml exec -T backend curl -f http://localhost:8080/health || echo "Backend health check failed"

          # Stop services
          docker compose -f docker/docker-compose.yml down

  code-quality:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Run code quality checks
        run: |
          docker run --rm -v $(pwd):/workspace -w /workspace rust:1.83 sh -c '
            rustup component add clippy rustfmt
            cargo fmt --check || (echo "Code formatting issues found. Run: cargo fmt" && exit 1)
            cargo clippy --all-targets --all-features -- -D warnings
          '

      - name: Run security audit
        run: |
          docker run --rm -v $(pwd):/workspace -w /workspace rust:1.83 sh -c '
            cargo install cargo-audit
            cargo audit
          '

  integration-tests:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Create .env file from secrets
        run: |
          cat > .env << EOF
          # Database configuration
          DATABASE_URL=postgresql://postgres:${{ secrets.POSTGRES_PASSWORD || 'SecurePass123' }}@db:5432/rusttracker
          POSTGRES_DB=rusttracker
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'SecurePass123' }}
          POSTGRES_HOST=localhost
          POSTGRES_PORT=5432

          # Backend configuration
          RUST_LOG=info
          PORT=8080
          JWT_SECRET=${{ secrets.JWT_SECRET || '9Kf2BmWpX7vYq3RzN8HtE5SaG4JdLcVnUx6AbC1iMhOyP0QwZ' }}
          JWT_EXPIRY_HOURS=24

          # Frontend configuration
          FRONTEND_PORT=3000

          # Environment
          APP_ENV=test

          # Rate limiting settings
          MAX_REQUESTS_PER_MINUTE=100
          RATE_LIMIT_WINDOW_MS=60000
          EOF

      - name: Run integration tests
        run: |
          echo "Running integration tests..."
          make quick-test backend

      - name: Run end-to-end tests
        run: |
          echo "Starting services for E2E testing..."
          docker compose -f docker/docker-compose.yml up -d

          # Wait for services
          sleep 45

          # Test API endpoints
          echo "Testing API endpoints..."

          # Test health endpoint
          curl -f http://localhost:8080/health || (echo "Health endpoint failed" && exit 1)

          # Test tasks endpoint
          curl -f http://localhost:8080/api/tasks || (echo "Tasks endpoint failed" && exit 1)

          # Test frontend
          curl -f http://localhost:3000 || (echo "Frontend failed" && exit 1)

          echo "E2E tests completed successfully"

          # Cleanup
          docker compose -f docker/docker-compose.yml down

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality, integration-tests]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Create staging .env file
        env:
          STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          STAGING_JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
        run: |
          cat > .env << EOF
          # Database configuration
          DATABASE_URL=${STAGING_DATABASE_URL:-postgresql://${{ secrets.POSTGRES_USER || 'postgres' }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_DB || 'rusttracker' }}}
          POSTGRES_DB=${{ secrets.POSTGRES_DB || 'rusttracker' }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_HOST=localhost
          POSTGRES_PORT=5432

          # Backend configuration
          RUST_LOG=info
          PORT=8080
          JWT_SECRET=${STAGING_JWT_SECRET:-${{ secrets.JWT_SECRET }}}
          JWT_EXPIRY_HOURS=24

          # Frontend configuration
          FRONTEND_PORT=3000

          # Environment
          APP_ENV=staging

          # Rate limiting settings
          MAX_REQUESTS_PER_MINUTE=${{ secrets.MAX_REQUESTS_PER_MINUTE || '100' }}
          RATE_LIMIT_WINDOW_MS=${{ secrets.RATE_LIMIT_WINDOW_MS || '60000' }}
          EOF

      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          echo "Staging deployment would occur here"
          echo "This could include:"
          echo "- Building optimized Docker images"
          echo "- Pushing to container registry"
          echo "- Deploying to staging infrastructure"
          echo "- Running smoke tests"

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality, integration-tests]
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Create production .env file
        env:
          PRODUCTION_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          PRODUCTION_JWT_SECRET: ${{ secrets.PRODUCTION_JWT_SECRET }}
        run: |
          cat > .env << EOF
          # Database configuration
          DATABASE_URL=${PRODUCTION_DATABASE_URL:-postgresql://${{ secrets.POSTGRES_USER || 'postgres' }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_DB || 'rusttracker' }}}
          POSTGRES_DB=${{ secrets.POSTGRES_DB || 'rusttracker' }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_HOST=localhost
          POSTGRES_PORT=5432

          # Backend configuration
          RUST_LOG=warn
          PORT=8080
          JWT_SECRET=${PRODUCTION_JWT_SECRET:-${{ secrets.JWT_SECRET }}}
          JWT_EXPIRY_HOURS=24

          # Frontend configuration
          FRONTEND_PORT=3000

          # Environment
          APP_ENV=production

          # Rate limiting settings
          MAX_REQUESTS_PER_MINUTE=${{ secrets.PRODUCTION_MAX_REQUESTS_PER_MINUTE || '60' }}
          RATE_LIMIT_WINDOW_MS=${{ secrets.PRODUCTION_RATE_LIMIT_WINDOW_MS || '60000' }}
          EOF

      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          echo "Production deployment would occur here"
          echo "This could include:"
          echo "- Building optimized Docker images"
          echo "- Pushing to container registry"
          echo "- Blue-green deployment"
          echo "- Health checks and rollback capability"
          echo "- Production smoke tests"

  notification:
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality, integration-tests]
    if: always()

    steps:
      - name: Pipeline status notification
        run: |
          if [[ "${{ needs.build-and-test.result }}" == "success" && 
                "${{ needs.code-quality.result }}" == "success" && 
                "${{ needs.integration-tests.result }}" == "success" ]]; then
            echo "SUCCESS: CI/CD pipeline completed successfully"
            echo "All tests passed and quality checks completed"
          else
            echo "FAILURE: CI/CD pipeline failed"
            echo "Build: ${{ needs.build-and-test.result }}"
            echo "Quality: ${{ needs.code-quality.result }}"
            echo "Integration: ${{ needs.integration-tests.result }}"
          fi
